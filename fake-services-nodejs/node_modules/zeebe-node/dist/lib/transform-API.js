"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normaliseAPI1 = exports.transformAPI0ReqToAPI1 = exports.makeAPI1ResAPI0Compatible = void 0;
// @TODO: fix spelling
const ZeroToOneMapping = [
    ['workflows', 'processs'],
    ['workflow', 'process'],
    ['Workflows', 'Processs'],
    ['Workflow', 'Process']
];
const OneToZeroMapping = [
    ['processes', 'workflows'],
    ['Processes', 'Workflows'],
    ['process', 'workflow'],
    ['Process', 'Workflow'],
];
const NormaliseOneMapping = [
    ['processs', 'processes'],
    ['Processs', 'processes']
];
const IgnoreDuringTransform = ['bpmnProcessId'];
function makeAPI1ResAPI0Compatible(api1Res) {
    const extend = (key, value) => {
        var _a;
        return (_a = OneToZeroMapping.reduce((curr, m) => curr === undefined && key.includes(m[0]) && !IgnoreDuringTransform.includes(key) ?
            { [key.replace(m[0], m[1])]: value, [key]: value } :
            curr, undefined)) !== null && _a !== void 0 ? _a : { [key]: value };
    };
    return typeof api1Res === 'object'
        ? Object.keys(api1Res).reduce((acc, key) => {
            if (!Array.isArray(api1Res[key])) {
                return { ...acc, ...extend(key, api1Res[key]) };
            }
            else {
                // recursively transform
                const api0Key = Object.keys(extend(key, api1Res[key]))[0];
                return { ...acc, [key]: api1Res[key], [api0Key]: api1Res[key].map(makeAPI1ResAPI0Compatible) };
            }
        }, {})
        : api1Res;
}
exports.makeAPI1ResAPI0Compatible = makeAPI1ResAPI0Compatible;
function transformAPI0ReqToAPI1(api0Object) {
    const replace = (key) => {
        var _a;
        return (_a = ZeroToOneMapping.reduce((curr, m) => curr === undefined && key.includes(m[0]) && !IgnoreDuringTransform.includes(key) ?
            key.replace(m[0], m[1]) :
            curr, undefined)) !== null && _a !== void 0 ? _a : key;
    };
    return typeof api0Object === 'object'
        ? Object.keys(api0Object).reduce((acc, key) => {
            if (!Array.isArray(api0Object[key])) {
                return { ...acc, [replace(key)]: api0Object[key] };
            }
            else {
                // recursively transform
                const newKey = replace(key);
                return { ...acc, [newKey]: api0Object[key].map(transformAPI0ReqToAPI1) };
            }
        }, {})
        : api0Object;
}
exports.transformAPI0ReqToAPI1 = transformAPI0ReqToAPI1;
// Deals with the misspelling of 'processes' in the gRPC API
function normaliseAPI1(thing) {
    const replace = key => NormaliseOneMapping.reduce((curr, m) => key.includes(m[0]) ?
        key.replace(m[0], m[1]) :
        curr, key);
    return typeof thing === 'object'
        ? Object.keys(thing).reduce((acc, key) => ({ ...acc, [replace(key)]: thing[key] }), {})
        : thing;
}
exports.normaliseAPI1 = normaliseAPI1;
//# sourceMappingURL=transform-API.js.map